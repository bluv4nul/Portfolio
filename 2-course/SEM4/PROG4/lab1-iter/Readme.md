# Лабораторная работа: Итераторы и сопрограммы в Python

## Цель работы
Изучение и практическое применение двух фундаментальных концепций Python: итераторов для обработки последовательностей и сопрограмм для организации потока выполнения с двусторонней коммуникацией.

## Выполненные задания

### Задание 1.1: Итератор с методами __iter__ и __next__
Реализован классический итератор, который последовательно обрабатывает коллекцию данных. Особенность данного итератора заключается в "ленивой" фильтрации — элементы проверяются и возвращаются по мере запроса, что позволяет эффективно работать с большими объемами данных.

**Принцип работы:**
- При инициализации принимает произвольную коллекцию чисел
- Постепенно проходит по элементам, пропуская те, которые не соответствуют критериям
- Возвращает только числа, принадлежащие последовательности Фибоначчи
- Автоматически завершает работу при достижении конца коллекции

### Задание 1.2: Итератор с методом __getitem__
Реализован альтернативный вариант итератора, использующий другой подход к обработке данных. В отличие от первого варианта, этот итератор предварительно фильтрует всю коллекцию при создании, что обеспечивает быстрый доступ к элементам по индексу.

**Особенности реализации:**
- Однократная предварительная обработка данных
- Поддержка индексированного доступа к результатам
- Более предсказуемое поведение при многократном использовании

### Задание 2: Сопрограмма для генерации чисел Фибоначчи
Реализована специализированная сопрограмма, демонстрирующая принцип кооперативной многозадачности. Данная реализация использует механизм `yield` для организации двустороннего обмена данными между вызывающей и вызываемой сторонами.

**Ключевые возможности:**
- Генерация произвольного количества чисел Фибоначчи по запросу
- Проверка корректности входных данных
- Возможность многократного использования без пересоздания
- Организация потока выполнения с сохранением состояния между вызовами

## Архитектура решения

### Модуль main.py
Содержит полную реализацию всех требуемых компонентов:

1. **Вспомогательная функция проверки чисел** — определяет принадлежность числа к последовательности Фибоначчи с использованием математического критерия.

2. **Сопрограмма генерации** — реализует логику последовательной генерации чисел с поддержкой приема параметров через механизм `send`.

3. **Декоратор инициализации** — обеспечивает правильную подготовку сопрограмм к работе, автоматизируя необходимые подготовительные действия.

4. **Классический итератор** — предоставляет интерфейс последовательного доступа к отфильтрованным данным.

5. **Упрощенный итератор** — альтернативная реализация с предварительной обработкой и индексированным доступом.

### Модуль тестирования
Включен отдельный файл с комплексной проверкой корректности работы всех реализованных компонентов. Тесты охватывают различные сценарии использования, включая обработку граничных случаев и некорректных данных.

## Принципиальные отличия подходов

### Итераторы vs Сопрограммы
- **Итераторы** предоставляют односторонний поток данных: от источника к потребителю
- **Сопрограммы** организуют двустороннюю коммуникацию, позволяя внешнему коду влиять на внутреннее состояние

### Два типа итераторов
- **Ленивая обработка** — экономия памяти при работе с большими данными, но потенциально более медленный доступ
- **Предварительная фильтрация** — быстрый произвольный доступ, но требующий полной загрузки данных в память

## Области применения

### Итераторы оптимальны для:
- Обработки потоков данных неизвестной длины
- Работы с ресурсоемкими источниками информации
- Ситуаций, где требуется поэлементная обработка без загрузки всей коллекции

### Сопрограммы эффективны для:
- Генерации последовательностей по требованию
- Задач, требующих поддержания состояния между вызовами
- Реализации кооперативной многозадачности в одном потоке выполнения

## Результаты работы
В ходе лабораторной работы успешно продемонстрированы различные подходы к организации потока данных в Python. Реализованные компоненты иллюстрируют ключевые аспекты работы с последовательностями и управления выполнением, предоставляя гибкие инструменты для решения широкого круга задач обработки данных.

Все компоненты прошли комплексное тестирование и демонстрируют корректное поведение в различных сценариях использования, включая обработку некорректных входных данных и работу с коллекциями различного размера.